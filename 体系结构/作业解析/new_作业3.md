这是一个关于操作系统虚拟内存、TLB（转换后备缓冲器）和页面置换算法（LRU）的详细解题步骤。

### 1. 题目信息梳理与初始化

首先，我们需要明确系统参数和初始状态：

*   **地址空间**：8-bit 虚拟地址。
*   **物理内存**：128 bytes。
*   **页面大小**：16 bytes。
    *   **物理页框数 (PPN)** = 总内存 / 页大小 = $128 / 16 = 8$ 个页框 (编号 0-7)。
    *   **虚拟页数 (VPN)** = $2^8 / 16 = 16$ 个虚拟页 (编号 0-15)。
*   **TLB**：容量 3 个条目，策略为 LRU（最近最少使用）。
*   **页表**：存放在内存中（占用物理页 7）。
*   **初始物理内存分布**：
    *   PPN 0: 空
    *   PPN 1: VPN 13
    *   PPN 2: VPN 5
    *   PPN 3: VPN 2
    *   PPN 4: 空
    *   PPN 5: VPN 0
    *   PPN 6: 空
    *   PPN 7: 页表 (Page Table)
*   **初始 TLB 内容**：VPN {0, 2, 13}。
    *   *注：题目未明确初始 LRU 顺序，假设初始状态它们处于静止态，随后的访问将决定顺序。*
*   **访问序列**：0, 13, 5, 2, 14, 14, 13, 6, 6, 13, 15, 14, 15, 13, 4, 3

---

### 2. 逐步模拟访问过程

我们需要跟踪三个主要状态的变化：
1.  **TLB 内容**（维护一个 LRU 栈，左边为最近使用 MRU，右边为最近最少使用 LRU）。
2.  **物理页分配情况**（用于处理 Page Fault）。
3.  **物理页访问热度**（用于页面置换的 LRU，题目提示“按照物理页访问的热度实现LRU”）。

**初始状态：**
*   **TLB**: [0, 2, 13] (无序集合)
*   **物理页占用**: {1:VPN13, 2:VPN5, 3:VPN2, 5:VPN0, 7:PT}
*   **空闲物理页**: 0, 4, 6

#### 访问步骤详情：

1.  **访问 VPN 0**
    *   **TLB**: 命中 (0 在 TLB 中)。**[Hit]**
    *   **TLB 更新**: 0 移至 MRU。Stack: `[0, 2, 13]` (假设 2, 13 在后)。
    *   **物理页**: 访问 PPN 5。

2.  **访问 VPN 13**
    *   **TLB**: 命中 (13 在 TLB 中)。**[Hit]**
    *   **TLB 更新**: 13 移至 MRU。Stack: `[13, 0, 2]`。
    *   **物理页**: 访问 PPN 1。

3.  **访问 VPN 5**
    *   **TLB**: 未命中 (5 不在 TLB)。**[Miss]**
    *   **查找页表**: 5 在内存中吗？是的，在 PPN 2。
    *   **TLB 更新**: 淘汰 LRU (即 2)，填入 5。Stack: `[5, 13, 0]`。
    *   **物理页**: 访问 PPN 2。

4.  **访问 VPN 2**
    *   **TLB**: 未命中 (2 刚被淘汰)。**[Miss]**
    *   **查找页表**: 2 在内存中吗？是的，在 PPN 3。
    *   **TLB 更新**: 淘汰 LRU (即 0)，填入 2。Stack: `[2, 5, 13]`。
    *   **物理页**: 访问 PPN 3。

5.  **访问 VPN 14**
    *   **TLB**: 未命中。**[Miss]**
    *   **查找页表**: 14 在内存中吗？不在。**[Page Fault]**
    *   **分配**: 有空闲页吗？有 (0, 4, 6)。选择 **PPN 0**[一般按照从小到大顺序分配]。
    *   **映射**: VPN 14 -> PPN 0。
    *   **TLB 更新**: 淘汰 LRU (即 13)，填入 14。Stack: `[14, 2, 5]`。
    *   **物理页**: 访问 PPN 0。

6.  **访问 VPN 14**
    *   **TLB**: 命中。**[Hit]**
    *   **TLB 更新**: 14 保持 MRU。Stack: `[14, 2, 5]`。
    *   **物理页**: 访问 PPN 0。

7.  **访问 VPN 13**
    *   **TLB**: 未命中 (之前被淘汰)。**[Miss]**
    *   **查找页表**: 13 在内存中吗？是的，在 PPN 1。
    *   **TLB 更新**: 淘汰 LRU (即 5)，填入 13。Stack: `[13, 14, 2]`。
    *   **物理页**: 访问 PPN 1。

8.  **访问 VPN 6**
    *   **TLB**: 未命中。**[Miss]**
    *   **查找页表**: 6 在内存中吗？不在。**[Page Fault]**
    *   **分配**: 有空闲页吗？有 (4, 6)。选择 **PPN 4**。
    *   **映射**: VPN 6 -> PPN 4。
    *   **TLB 更新**: 淘汰 LRU (即 2)，填入 6。Stack: `[6, 13, 14]`。
    *   **物理页**: 访问 PPN 4。

9.  **访问 VPN 6**
    *   **TLB**: 命中。**[Hit]**
    *   **TLB 更新**: 6 保持 MRU。Stack: `[6, 13, 14]`。
    *   **物理页**: 访问 PPN 4。

10. **访问 VPN 13**
    *   **TLB**: 命中。**[Hit]**
    *   **TLB 更新**: 13 移至 MRU。Stack: `[13, 6, 14]`。
    *   **物理页**: 访问 PPN 1。

11. **访问 VPN 15**
    *   **TLB**: 未命中。**[Miss]**
    *   **查找页表**: 15 在内存中吗？不在。**[Page Fault]**
    *   **分配**: 有空闲页吗？有 (6)。选择 **PPN 6**。
    *   **映射**: VPN 15 -> PPN 6。
    *   **TLB 更新**: 淘汰 LRU (即 14)，填入 15。Stack: `[15, 13, 6]`。
    *   **物理页**: 访问 PPN 6。

12. **访问 VPN 14**
    *   **TLB**: 未命中。**[Miss]**
    *   **查找页表**: 14 在内存中吗？是的，在 PPN 0。
    *   **TLB 更新**: 淘汰 LRU (即 6)，填入 14。Stack: `[14, 15, 13]`。
    *   **物理页**: 访问 PPN 0。

13. **访问 VPN 15**
    *   **TLB**: 命中。**[Hit]**
    *   **TLB 更新**: 15 移至 MRU。Stack: `[15, 14, 13]`。
    *   **物理页**: 访问 PPN 6。

14. **访问 VPN 13**
    *   **TLB**: 命中。**[Hit]**
    *   **TLB 更新**: 13 移至 MRU。Stack: `[13, 15, 14]`。
    *   **物理页**: 访问 PPN 1。

15. **访问 VPN 4**
    *   **TLB**: 未命中。**[Miss]**
    *   **查找页表**: 4 在内存中吗？不在。**[Page Fault]**
    *   **分配**: 有空闲页吗？没有 (0-7 全满)。需要置换。
    *   **置换策略 (物理页 LRU)**:
        *   回顾物理页最近访问时间：
            *   PPN 1 (VPN 13): 刚访问 (步14)
            *   PPN 6 (VPN 15): 很近 (步13)
            *   PPN 0 (VPN 14): 近 (步12)
            *   PPN 4 (VPN 6): 中等 (步9)
            *   PPN 3 (VPN 2): 远 (步4)
            *   PPN 2 (VPN 5): 远 (步3)
            *   PPN 5 (VPN 0): 最远 (步1) -> **Victim: PPN 5**
    *   **映射**: 淘汰 PPN 5 中的 VPN 0，装入 VPN 4。**VPN 4 -> PPN 5**。
    *   **TLB 更新**: 淘汰 LRU (即 14)，填入 4。Stack: `[4, 13, 15]`。
    *   **物理页**: 访问 PPN 5。

16. **访问 VPN 3**
    *   **TLB**: 未命中。**[Miss]**
    *   **查找页表**: 3 在内存中吗？不在。**[Page Fault]**
    *   **分配**: 无空闲页。
    *   **置换策略 (物理页 LRU)**:
        *   PPN 5 (VPN 4): 刚访问 (步15)
        *   ... PPN 1, 6, 0, 4 都比较新。
        *   剩下的老页面：PPN 3 (上次访问步4), PPN 2 (上次访问步3)。
        *   最久未访问的是 **PPN 2** (VPN 5)。-> **Victim: PPN 2**
    *   **映射**: 淘汰 PPN 2 中的 VPN 5，装入 VPN 3。**VPN 3 -> PPN 2**。
    *   **TLB 更新**: 淘汰 LRU (即 15)，填入 3。Stack: `[3, 4, 13]` (其中3是最新，13是最近最少)。
    *   **物理页**: 访问 PPN 2。

---

### 3. 结果汇总与解答

#### (a) TLB的命中率为多少？

我们统计上述步骤中的命中情况：
*   Hits (命中):
    1.  VPN 0 (Step 1)
    2.  VPN 13 (Step 2)
    3.  VPN 14 (Step 6)
    4.  VPN 6 (Step 9)
    5.  VPN 13 (Step 10)
    6.  VPN 15 (Step 13)
    7.  VPN 13 (Step 14)

总命中数 = 7。
总访问次数 = 16。

**命中率 = 7/16**

#### (b) 全部访问结束后，TLB里面的内容是什么？

根据步骤 16 结束后的状态：
TLB 的 LRU 栈为（从最近使用到最近最少使用）：`[3, 4, 13]`。
其中：
*   3 是刚刚访问的 (Step 16)。
*   4 是 Step 15 访问的。
*   13 是 Step 14 访问的。

**TLB 内容为：3, 4, 13 (对应的 VPN)**

#### (c) 全部访问结束后，页表的内容是什么？

我们需要列出物理页 0 到 7 当前存储的 Virtual Page (VPN)：

*   **PPN 0**: VPN 14 (在 Step 5 分配，之后未被置换)
*   **PPN 1**: VPN 13 (初始存在，一直热度较高，未被置换)
*   **PPN 2**: VPN 3 (在 Step 16 置换了原来的 VPN 5)
*   **PPN 3**: VPN 2 (初始存在，虽然很久没访问，但在 Step 16 时比 PPN 2 稍微新一点点，所以幸存)
*   **PPN 4**: VPN 6 (在 Step 8 分配)
*   **PPN 5**: VPN 4 (在 Step 15 置换了原来的 VPN 0)
*   **PPN 6**: VPN 15 (在 Step 11 分配)
*   **PPN 7**: Page Table (固定占用)

**页表内容（物理页对应内容）如下：**
*   PPN 0 -> **14**
*   PPN 1 -> **13**
*   PPN 2 -> **3**
*   PPN 3 -> **2**
*   PPN 4 -> **6**
*   PPN 5 -> **4**
*   PPN 6 -> **15**
*   PPN 7 -> **Page Table**