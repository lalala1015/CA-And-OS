
### 1. 变量 a 的最终值可能是多少？解释原因

**答案：** **0, 1, 2**

**原因：**
虽然指令 T0.2 的循环等待保证了 T1.1（`flag=1`）一定在 T0.3（读 X）之前执行，且根据顺序一致性，T1.0（写 0）必然在 T1.1 之前发生，因此 **T1.0 必然在 T0.3 之前发生**。
但是，T1.0 与 T0 的前两条写指令（T0.0 写 1、T0.1 加 1）之间的执行顺序是不确定的（存在竞态）。
*   若 T1.0 最后执行（覆盖 T0 的操作），则 X=0，a=0。
*   若 T1.0 插在 T0.0 与 T0.1 之间，则 X=1，a=1。
*   若 T1.0 最先执行，则 X=2，a=2。

### 2. 变量 X[0] 的最终值可能是多少？解释原因。

**答案：** **0, 2, 4**

**原因：**
根据同步逻辑，T1.0（T1 对 X 的唯一写操作）必然在 T0.3 之前发生，而 T0.3 必然在 T0.4 之前发生。因此，**T0.4（X = a\*2）一定是全程序对 X 的最后一次写入**。
根据 Q1 的结论，a 的取值为 {0, 1, 2}，代入公式 `X = a * 2`，X 的最终值可能为 0, 2, 4。

### 3. 变量 b 的最终值可能是多少？解释原因。

**答案：** **0, 1, 2, 4**

**原因：**
指令 T1.2（b = X[0]）与 T0 的写操作之间没有同步约束，存在竞态：
1.  **若 T1.2 执行较早**（在 T0.4 翻倍之前）：它可能读到 T0.0、T0.1 和 T1.0 竞态下的中间结果，即此时 X 的值可能为 0, 1, 2。
2.  **若 T1.2 执行较晚**（在 T0.4 翻倍之后）：它将读到 X 的最终结果，即 0, 2, 4。
取两者的并集：{0, 1, 2} ∪ {0, 2, 4} = {0, 1, 2, 4}。

### 4. 最小改动填表

**说明**：为了保证 a 和 b 在结束时相等，必须确保两点：
1.  b 读取时，T0 已经完成了对 X 的初始化计算（T0.0 和 T0.1），避免 b 读到旧值 0。
2.  b 读取时，T0 还没有执行翻倍操作（T0.4），避免 b 读到翻倍后的值。

因此需要引入一个新的共享变量（例如 `flag2`，初始化为 0），进行**双向握手**。

**填写内容如下：**

| Thread T0 | Thread T1 |
| :--- | :--- |
| 指令 T0.0 X[0] = 1; | 指令 T1.0 X[0] = 0; |
| 指令 T0.1 X[0] += 1; | 指令 T1.1 flag[0] = 1; |
| **指令 T0.15 flag2[0] = 1;** <br> *(告知 T1：X基础值已就绪)* | **指令 T1.15 while(flag2[0] == 0);** <br> *(等待 T0 完成基础计算)* |
| 指令 T0.2 while(flag[0] == 0); | 指令 T1.2 b = X[0]; |
| 指令 T0.3 a = X[0]; | **指令 T1.3 flag2[0] = 2;** <br> *(告知 T0：b 已读完)* |
| **指令 T0.35 while(flag2[0] != 2);** <br> *(等待 T1 读完 b 才能翻倍)* | |
| 指令 T0.4 X[0] = a*2; | |
